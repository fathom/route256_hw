package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/clients/grpc/product_client.ProductService -o ./mocks/product_service_minimock.go -n ProductServiceMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ProductServiceMock implements product_client.ProductService
type ProductServiceMock struct {
	t minimock.Tester

	funcGetProduct          func(ctx context.Context, sku uint32) (s1 string, u1 uint32, err error)
	inspectFuncGetProduct   func(ctx context.Context, sku uint32)
	afterGetProductCounter  uint64
	beforeGetProductCounter uint64
	GetProductMock          mProductServiceMockGetProduct

	funcListSkus          func(ctx context.Context, startAfterSku uint32, count uint32) (ua1 []uint32, err error)
	inspectFuncListSkus   func(ctx context.Context, startAfterSku uint32, count uint32)
	afterListSkusCounter  uint64
	beforeListSkusCounter uint64
	ListSkusMock          mProductServiceMockListSkus
}

// NewProductServiceMock returns a mock for product_client.ProductService
func NewProductServiceMock(t minimock.Tester) *ProductServiceMock {
	m := &ProductServiceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetProductMock = mProductServiceMockGetProduct{mock: m}
	m.GetProductMock.callArgs = []*ProductServiceMockGetProductParams{}

	m.ListSkusMock = mProductServiceMockListSkus{mock: m}
	m.ListSkusMock.callArgs = []*ProductServiceMockListSkusParams{}

	return m
}

type mProductServiceMockGetProduct struct {
	mock               *ProductServiceMock
	defaultExpectation *ProductServiceMockGetProductExpectation
	expectations       []*ProductServiceMockGetProductExpectation

	callArgs []*ProductServiceMockGetProductParams
	mutex    sync.RWMutex
}

// ProductServiceMockGetProductExpectation specifies expectation struct of the ProductService.GetProduct
type ProductServiceMockGetProductExpectation struct {
	mock    *ProductServiceMock
	params  *ProductServiceMockGetProductParams
	results *ProductServiceMockGetProductResults
	Counter uint64
}

// ProductServiceMockGetProductParams contains parameters of the ProductService.GetProduct
type ProductServiceMockGetProductParams struct {
	ctx context.Context
	sku uint32
}

// ProductServiceMockGetProductResults contains results of the ProductService.GetProduct
type ProductServiceMockGetProductResults struct {
	s1  string
	u1  uint32
	err error
}

// Expect sets up expected params for ProductService.GetProduct
func (mmGetProduct *mProductServiceMockGetProduct) Expect(ctx context.Context, sku uint32) *mProductServiceMockGetProduct {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &ProductServiceMockGetProductExpectation{}
	}

	mmGetProduct.defaultExpectation.params = &ProductServiceMockGetProductParams{ctx, sku}
	for _, e := range mmGetProduct.expectations {
		if minimock.Equal(e.params, mmGetProduct.defaultExpectation.params) {
			mmGetProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetProduct.defaultExpectation.params)
		}
	}

	return mmGetProduct
}

// Inspect accepts an inspector function that has same arguments as the ProductService.GetProduct
func (mmGetProduct *mProductServiceMockGetProduct) Inspect(f func(ctx context.Context, sku uint32)) *mProductServiceMockGetProduct {
	if mmGetProduct.mock.inspectFuncGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("Inspect function is already set for ProductServiceMock.GetProduct")
	}

	mmGetProduct.mock.inspectFuncGetProduct = f

	return mmGetProduct
}

// Return sets up results that will be returned by ProductService.GetProduct
func (mmGetProduct *mProductServiceMockGetProduct) Return(s1 string, u1 uint32, err error) *ProductServiceMock {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Set")
	}

	if mmGetProduct.defaultExpectation == nil {
		mmGetProduct.defaultExpectation = &ProductServiceMockGetProductExpectation{mock: mmGetProduct.mock}
	}
	mmGetProduct.defaultExpectation.results = &ProductServiceMockGetProductResults{s1, u1, err}
	return mmGetProduct.mock
}

// Set uses given function f to mock the ProductService.GetProduct method
func (mmGetProduct *mProductServiceMockGetProduct) Set(f func(ctx context.Context, sku uint32) (s1 string, u1 uint32, err error)) *ProductServiceMock {
	if mmGetProduct.defaultExpectation != nil {
		mmGetProduct.mock.t.Fatalf("Default expectation is already set for the ProductService.GetProduct method")
	}

	if len(mmGetProduct.expectations) > 0 {
		mmGetProduct.mock.t.Fatalf("Some expectations are already set for the ProductService.GetProduct method")
	}

	mmGetProduct.mock.funcGetProduct = f
	return mmGetProduct.mock
}

// When sets expectation for the ProductService.GetProduct which will trigger the result defined by the following
// Then helper
func (mmGetProduct *mProductServiceMockGetProduct) When(ctx context.Context, sku uint32) *ProductServiceMockGetProductExpectation {
	if mmGetProduct.mock.funcGetProduct != nil {
		mmGetProduct.mock.t.Fatalf("ProductServiceMock.GetProduct mock is already set by Set")
	}

	expectation := &ProductServiceMockGetProductExpectation{
		mock:   mmGetProduct.mock,
		params: &ProductServiceMockGetProductParams{ctx, sku},
	}
	mmGetProduct.expectations = append(mmGetProduct.expectations, expectation)
	return expectation
}

// Then sets up ProductService.GetProduct return parameters for the expectation previously defined by the When method
func (e *ProductServiceMockGetProductExpectation) Then(s1 string, u1 uint32, err error) *ProductServiceMock {
	e.results = &ProductServiceMockGetProductResults{s1, u1, err}
	return e.mock
}

// GetProduct implements product_client.ProductService
func (mmGetProduct *ProductServiceMock) GetProduct(ctx context.Context, sku uint32) (s1 string, u1 uint32, err error) {
	mm_atomic.AddUint64(&mmGetProduct.beforeGetProductCounter, 1)
	defer mm_atomic.AddUint64(&mmGetProduct.afterGetProductCounter, 1)

	if mmGetProduct.inspectFuncGetProduct != nil {
		mmGetProduct.inspectFuncGetProduct(ctx, sku)
	}

	mm_params := &ProductServiceMockGetProductParams{ctx, sku}

	// Record call args
	mmGetProduct.GetProductMock.mutex.Lock()
	mmGetProduct.GetProductMock.callArgs = append(mmGetProduct.GetProductMock.callArgs, mm_params)
	mmGetProduct.GetProductMock.mutex.Unlock()

	for _, e := range mmGetProduct.GetProductMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.u1, e.results.err
		}
	}

	if mmGetProduct.GetProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetProduct.GetProductMock.defaultExpectation.Counter, 1)
		mm_want := mmGetProduct.GetProductMock.defaultExpectation.params
		mm_got := ProductServiceMockGetProductParams{ctx, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetProduct.t.Errorf("ProductServiceMock.GetProduct got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetProduct.GetProductMock.defaultExpectation.results
		if mm_results == nil {
			mmGetProduct.t.Fatal("No results are set for the ProductServiceMock.GetProduct")
		}
		return (*mm_results).s1, (*mm_results).u1, (*mm_results).err
	}
	if mmGetProduct.funcGetProduct != nil {
		return mmGetProduct.funcGetProduct(ctx, sku)
	}
	mmGetProduct.t.Fatalf("Unexpected call to ProductServiceMock.GetProduct. %v %v", ctx, sku)
	return
}

// GetProductAfterCounter returns a count of finished ProductServiceMock.GetProduct invocations
func (mmGetProduct *ProductServiceMock) GetProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.afterGetProductCounter)
}

// GetProductBeforeCounter returns a count of ProductServiceMock.GetProduct invocations
func (mmGetProduct *ProductServiceMock) GetProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetProduct.beforeGetProductCounter)
}

// Calls returns a list of arguments used in each call to ProductServiceMock.GetProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetProduct *mProductServiceMockGetProduct) Calls() []*ProductServiceMockGetProductParams {
	mmGetProduct.mutex.RLock()

	argCopy := make([]*ProductServiceMockGetProductParams, len(mmGetProduct.callArgs))
	copy(argCopy, mmGetProduct.callArgs)

	mmGetProduct.mutex.RUnlock()

	return argCopy
}

// MinimockGetProductDone returns true if the count of the GetProduct invocations corresponds
// the number of defined expectations
func (m *ProductServiceMock) MinimockGetProductDone() bool {
	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProduct != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetProductInspect logs each unmet expectation
func (m *ProductServiceMock) MinimockGetProductInspect() {
	for _, e := range m.GetProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductServiceMock.GetProduct with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetProductMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		if m.GetProductMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProductServiceMock.GetProduct")
		} else {
			m.t.Errorf("Expected call to ProductServiceMock.GetProduct with params: %#v", *m.GetProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetProduct != nil && mm_atomic.LoadUint64(&m.afterGetProductCounter) < 1 {
		m.t.Error("Expected call to ProductServiceMock.GetProduct")
	}
}

type mProductServiceMockListSkus struct {
	mock               *ProductServiceMock
	defaultExpectation *ProductServiceMockListSkusExpectation
	expectations       []*ProductServiceMockListSkusExpectation

	callArgs []*ProductServiceMockListSkusParams
	mutex    sync.RWMutex
}

// ProductServiceMockListSkusExpectation specifies expectation struct of the ProductService.ListSkus
type ProductServiceMockListSkusExpectation struct {
	mock    *ProductServiceMock
	params  *ProductServiceMockListSkusParams
	results *ProductServiceMockListSkusResults
	Counter uint64
}

// ProductServiceMockListSkusParams contains parameters of the ProductService.ListSkus
type ProductServiceMockListSkusParams struct {
	ctx           context.Context
	startAfterSku uint32
	count         uint32
}

// ProductServiceMockListSkusResults contains results of the ProductService.ListSkus
type ProductServiceMockListSkusResults struct {
	ua1 []uint32
	err error
}

// Expect sets up expected params for ProductService.ListSkus
func (mmListSkus *mProductServiceMockListSkus) Expect(ctx context.Context, startAfterSku uint32, count uint32) *mProductServiceMockListSkus {
	if mmListSkus.mock.funcListSkus != nil {
		mmListSkus.mock.t.Fatalf("ProductServiceMock.ListSkus mock is already set by Set")
	}

	if mmListSkus.defaultExpectation == nil {
		mmListSkus.defaultExpectation = &ProductServiceMockListSkusExpectation{}
	}

	mmListSkus.defaultExpectation.params = &ProductServiceMockListSkusParams{ctx, startAfterSku, count}
	for _, e := range mmListSkus.expectations {
		if minimock.Equal(e.params, mmListSkus.defaultExpectation.params) {
			mmListSkus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListSkus.defaultExpectation.params)
		}
	}

	return mmListSkus
}

// Inspect accepts an inspector function that has same arguments as the ProductService.ListSkus
func (mmListSkus *mProductServiceMockListSkus) Inspect(f func(ctx context.Context, startAfterSku uint32, count uint32)) *mProductServiceMockListSkus {
	if mmListSkus.mock.inspectFuncListSkus != nil {
		mmListSkus.mock.t.Fatalf("Inspect function is already set for ProductServiceMock.ListSkus")
	}

	mmListSkus.mock.inspectFuncListSkus = f

	return mmListSkus
}

// Return sets up results that will be returned by ProductService.ListSkus
func (mmListSkus *mProductServiceMockListSkus) Return(ua1 []uint32, err error) *ProductServiceMock {
	if mmListSkus.mock.funcListSkus != nil {
		mmListSkus.mock.t.Fatalf("ProductServiceMock.ListSkus mock is already set by Set")
	}

	if mmListSkus.defaultExpectation == nil {
		mmListSkus.defaultExpectation = &ProductServiceMockListSkusExpectation{mock: mmListSkus.mock}
	}
	mmListSkus.defaultExpectation.results = &ProductServiceMockListSkusResults{ua1, err}
	return mmListSkus.mock
}

// Set uses given function f to mock the ProductService.ListSkus method
func (mmListSkus *mProductServiceMockListSkus) Set(f func(ctx context.Context, startAfterSku uint32, count uint32) (ua1 []uint32, err error)) *ProductServiceMock {
	if mmListSkus.defaultExpectation != nil {
		mmListSkus.mock.t.Fatalf("Default expectation is already set for the ProductService.ListSkus method")
	}

	if len(mmListSkus.expectations) > 0 {
		mmListSkus.mock.t.Fatalf("Some expectations are already set for the ProductService.ListSkus method")
	}

	mmListSkus.mock.funcListSkus = f
	return mmListSkus.mock
}

// When sets expectation for the ProductService.ListSkus which will trigger the result defined by the following
// Then helper
func (mmListSkus *mProductServiceMockListSkus) When(ctx context.Context, startAfterSku uint32, count uint32) *ProductServiceMockListSkusExpectation {
	if mmListSkus.mock.funcListSkus != nil {
		mmListSkus.mock.t.Fatalf("ProductServiceMock.ListSkus mock is already set by Set")
	}

	expectation := &ProductServiceMockListSkusExpectation{
		mock:   mmListSkus.mock,
		params: &ProductServiceMockListSkusParams{ctx, startAfterSku, count},
	}
	mmListSkus.expectations = append(mmListSkus.expectations, expectation)
	return expectation
}

// Then sets up ProductService.ListSkus return parameters for the expectation previously defined by the When method
func (e *ProductServiceMockListSkusExpectation) Then(ua1 []uint32, err error) *ProductServiceMock {
	e.results = &ProductServiceMockListSkusResults{ua1, err}
	return e.mock
}

// ListSkus implements product_client.ProductService
func (mmListSkus *ProductServiceMock) ListSkus(ctx context.Context, startAfterSku uint32, count uint32) (ua1 []uint32, err error) {
	mm_atomic.AddUint64(&mmListSkus.beforeListSkusCounter, 1)
	defer mm_atomic.AddUint64(&mmListSkus.afterListSkusCounter, 1)

	if mmListSkus.inspectFuncListSkus != nil {
		mmListSkus.inspectFuncListSkus(ctx, startAfterSku, count)
	}

	mm_params := &ProductServiceMockListSkusParams{ctx, startAfterSku, count}

	// Record call args
	mmListSkus.ListSkusMock.mutex.Lock()
	mmListSkus.ListSkusMock.callArgs = append(mmListSkus.ListSkusMock.callArgs, mm_params)
	mmListSkus.ListSkusMock.mutex.Unlock()

	for _, e := range mmListSkus.ListSkusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmListSkus.ListSkusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListSkus.ListSkusMock.defaultExpectation.Counter, 1)
		mm_want := mmListSkus.ListSkusMock.defaultExpectation.params
		mm_got := ProductServiceMockListSkusParams{ctx, startAfterSku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListSkus.t.Errorf("ProductServiceMock.ListSkus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListSkus.ListSkusMock.defaultExpectation.results
		if mm_results == nil {
			mmListSkus.t.Fatal("No results are set for the ProductServiceMock.ListSkus")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmListSkus.funcListSkus != nil {
		return mmListSkus.funcListSkus(ctx, startAfterSku, count)
	}
	mmListSkus.t.Fatalf("Unexpected call to ProductServiceMock.ListSkus. %v %v %v", ctx, startAfterSku, count)
	return
}

// ListSkusAfterCounter returns a count of finished ProductServiceMock.ListSkus invocations
func (mmListSkus *ProductServiceMock) ListSkusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSkus.afterListSkusCounter)
}

// ListSkusBeforeCounter returns a count of ProductServiceMock.ListSkus invocations
func (mmListSkus *ProductServiceMock) ListSkusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListSkus.beforeListSkusCounter)
}

// Calls returns a list of arguments used in each call to ProductServiceMock.ListSkus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListSkus *mProductServiceMockListSkus) Calls() []*ProductServiceMockListSkusParams {
	mmListSkus.mutex.RLock()

	argCopy := make([]*ProductServiceMockListSkusParams, len(mmListSkus.callArgs))
	copy(argCopy, mmListSkus.callArgs)

	mmListSkus.mutex.RUnlock()

	return argCopy
}

// MinimockListSkusDone returns true if the count of the ListSkus invocations corresponds
// the number of defined expectations
func (m *ProductServiceMock) MinimockListSkusDone() bool {
	for _, e := range m.ListSkusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSkusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSkusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSkus != nil && mm_atomic.LoadUint64(&m.afterListSkusCounter) < 1 {
		return false
	}
	return true
}

// MinimockListSkusInspect logs each unmet expectation
func (m *ProductServiceMock) MinimockListSkusInspect() {
	for _, e := range m.ListSkusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ProductServiceMock.ListSkus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListSkusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListSkusCounter) < 1 {
		if m.ListSkusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ProductServiceMock.ListSkus")
		} else {
			m.t.Errorf("Expected call to ProductServiceMock.ListSkus with params: %#v", *m.ListSkusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListSkus != nil && mm_atomic.LoadUint64(&m.afterListSkusCounter) < 1 {
		m.t.Error("Expected call to ProductServiceMock.ListSkus")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ProductServiceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetProductInspect()

		m.MinimockListSkusInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ProductServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ProductServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetProductDone() &&
		m.MinimockListSkusDone()
}
