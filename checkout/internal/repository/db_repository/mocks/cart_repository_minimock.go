package mocks

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i route256/checkout/internal/repository/db_repository.CartRepository -o ./mocks/cart_repository_minimock.go -n CartRepositoryMock

import (
	"context"
	"route256/checkout/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements db_repository.CartRepository
type CartRepositoryMock struct {
	t minimock.Tester

	funcAddToCart          func(ctx context.Context, userID int64, sku uint32, count uint32) (err error)
	inspectFuncAddToCart   func(ctx context.Context, userID int64, sku uint32, count uint32)
	afterAddToCartCounter  uint64
	beforeAddToCartCounter uint64
	AddToCartMock          mCartRepositoryMockAddToCart

	funcDeleteCart          func(ctx context.Context, userID int64, sku uint32) (err error)
	inspectFuncDeleteCart   func(ctx context.Context, userID int64, sku uint32)
	afterDeleteCartCounter  uint64
	beforeDeleteCartCounter uint64
	DeleteCartMock          mCartRepositoryMockDeleteCart

	funcDeleteUserCart          func(ctx context.Context, userID int64) (err error)
	inspectFuncDeleteUserCart   func(ctx context.Context, userID int64)
	afterDeleteUserCartCounter  uint64
	beforeDeleteUserCartCounter uint64
	DeleteUserCartMock          mCartRepositoryMockDeleteUserCart

	funcGetCartItem          func(ctx context.Context, userID int64, sku uint32) (c2 model.CartItem, err error)
	inspectFuncGetCartItem   func(ctx context.Context, userID int64, sku uint32)
	afterGetCartItemCounter  uint64
	beforeGetCartItemCounter uint64
	GetCartItemMock          mCartRepositoryMockGetCartItem

	funcListCart          func(ctx context.Context, userID int64) (ca1 []model.CartItem, err error)
	inspectFuncListCart   func(ctx context.Context, userID int64)
	afterListCartCounter  uint64
	beforeListCartCounter uint64
	ListCartMock          mCartRepositoryMockListCart

	funcUpdateCountCart          func(ctx context.Context, userID int64, sku uint32, count uint32) (err error)
	inspectFuncUpdateCountCart   func(ctx context.Context, userID int64, sku uint32, count uint32)
	afterUpdateCountCartCounter  uint64
	beforeUpdateCountCartCounter uint64
	UpdateCountCartMock          mCartRepositoryMockUpdateCountCart
}

// NewCartRepositoryMock returns a mock for db_repository.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddToCartMock = mCartRepositoryMockAddToCart{mock: m}
	m.AddToCartMock.callArgs = []*CartRepositoryMockAddToCartParams{}

	m.DeleteCartMock = mCartRepositoryMockDeleteCart{mock: m}
	m.DeleteCartMock.callArgs = []*CartRepositoryMockDeleteCartParams{}

	m.DeleteUserCartMock = mCartRepositoryMockDeleteUserCart{mock: m}
	m.DeleteUserCartMock.callArgs = []*CartRepositoryMockDeleteUserCartParams{}

	m.GetCartItemMock = mCartRepositoryMockGetCartItem{mock: m}
	m.GetCartItemMock.callArgs = []*CartRepositoryMockGetCartItemParams{}

	m.ListCartMock = mCartRepositoryMockListCart{mock: m}
	m.ListCartMock.callArgs = []*CartRepositoryMockListCartParams{}

	m.UpdateCountCartMock = mCartRepositoryMockUpdateCountCart{mock: m}
	m.UpdateCountCartMock.callArgs = []*CartRepositoryMockUpdateCountCartParams{}

	return m
}

type mCartRepositoryMockAddToCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddToCartExpectation
	expectations       []*CartRepositoryMockAddToCartExpectation

	callArgs []*CartRepositoryMockAddToCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockAddToCartExpectation specifies expectation struct of the CartRepository.AddToCart
type CartRepositoryMockAddToCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockAddToCartParams
	results *CartRepositoryMockAddToCartResults
	Counter uint64
}

// CartRepositoryMockAddToCartParams contains parameters of the CartRepository.AddToCart
type CartRepositoryMockAddToCartParams struct {
	ctx    context.Context
	userID int64
	sku    uint32
	count  uint32
}

// CartRepositoryMockAddToCartResults contains results of the CartRepository.AddToCart
type CartRepositoryMockAddToCartResults struct {
	err error
}

// Expect sets up expected params for CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Expect(ctx context.Context, userID int64, sku uint32, count uint32) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{}
	}

	mmAddToCart.defaultExpectation.params = &CartRepositoryMockAddToCartParams{ctx, userID, sku, count}
	for _, e := range mmAddToCart.expectations {
		if minimock.Equal(e.params, mmAddToCart.defaultExpectation.params) {
			mmAddToCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddToCart.defaultExpectation.params)
		}
	}

	return mmAddToCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Inspect(f func(ctx context.Context, userID int64, sku uint32, count uint32)) *mCartRepositoryMockAddToCart {
	if mmAddToCart.mock.inspectFuncAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddToCart")
	}

	mmAddToCart.mock.inspectFuncAddToCart = f

	return mmAddToCart
}

// Return sets up results that will be returned by CartRepository.AddToCart
func (mmAddToCart *mCartRepositoryMockAddToCart) Return(err error) *CartRepositoryMock {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	if mmAddToCart.defaultExpectation == nil {
		mmAddToCart.defaultExpectation = &CartRepositoryMockAddToCartExpectation{mock: mmAddToCart.mock}
	}
	mmAddToCart.defaultExpectation.results = &CartRepositoryMockAddToCartResults{err}
	return mmAddToCart.mock
}

// Set uses given function f to mock the CartRepository.AddToCart method
func (mmAddToCart *mCartRepositoryMockAddToCart) Set(f func(ctx context.Context, userID int64, sku uint32, count uint32) (err error)) *CartRepositoryMock {
	if mmAddToCart.defaultExpectation != nil {
		mmAddToCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddToCart method")
	}

	if len(mmAddToCart.expectations) > 0 {
		mmAddToCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddToCart method")
	}

	mmAddToCart.mock.funcAddToCart = f
	return mmAddToCart.mock
}

// When sets expectation for the CartRepository.AddToCart which will trigger the result defined by the following
// Then helper
func (mmAddToCart *mCartRepositoryMockAddToCart) When(ctx context.Context, userID int64, sku uint32, count uint32) *CartRepositoryMockAddToCartExpectation {
	if mmAddToCart.mock.funcAddToCart != nil {
		mmAddToCart.mock.t.Fatalf("CartRepositoryMock.AddToCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddToCartExpectation{
		mock:   mmAddToCart.mock,
		params: &CartRepositoryMockAddToCartParams{ctx, userID, sku, count},
	}
	mmAddToCart.expectations = append(mmAddToCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddToCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddToCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddToCartResults{err}
	return e.mock
}

// AddToCart implements db_repository.CartRepository
func (mmAddToCart *CartRepositoryMock) AddToCart(ctx context.Context, userID int64, sku uint32, count uint32) (err error) {
	mm_atomic.AddUint64(&mmAddToCart.beforeAddToCartCounter, 1)
	defer mm_atomic.AddUint64(&mmAddToCart.afterAddToCartCounter, 1)

	if mmAddToCart.inspectFuncAddToCart != nil {
		mmAddToCart.inspectFuncAddToCart(ctx, userID, sku, count)
	}

	mm_params := &CartRepositoryMockAddToCartParams{ctx, userID, sku, count}

	// Record call args
	mmAddToCart.AddToCartMock.mutex.Lock()
	mmAddToCart.AddToCartMock.callArgs = append(mmAddToCart.AddToCartMock.callArgs, mm_params)
	mmAddToCart.AddToCartMock.mutex.Unlock()

	for _, e := range mmAddToCart.AddToCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddToCart.AddToCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddToCart.AddToCartMock.defaultExpectation.Counter, 1)
		mm_want := mmAddToCart.AddToCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockAddToCartParams{ctx, userID, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddToCart.t.Errorf("CartRepositoryMock.AddToCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddToCart.AddToCartMock.defaultExpectation.results
		if mm_results == nil {
			mmAddToCart.t.Fatal("No results are set for the CartRepositoryMock.AddToCart")
		}
		return (*mm_results).err
	}
	if mmAddToCart.funcAddToCart != nil {
		return mmAddToCart.funcAddToCart(ctx, userID, sku, count)
	}
	mmAddToCart.t.Fatalf("Unexpected call to CartRepositoryMock.AddToCart. %v %v %v %v", ctx, userID, sku, count)
	return
}

// AddToCartAfterCounter returns a count of finished CartRepositoryMock.AddToCart invocations
func (mmAddToCart *CartRepositoryMock) AddToCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.afterAddToCartCounter)
}

// AddToCartBeforeCounter returns a count of CartRepositoryMock.AddToCart invocations
func (mmAddToCart *CartRepositoryMock) AddToCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddToCart.beforeAddToCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddToCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddToCart *mCartRepositoryMockAddToCart) Calls() []*CartRepositoryMockAddToCartParams {
	mmAddToCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddToCartParams, len(mmAddToCart.callArgs))
	copy(argCopy, mmAddToCart.callArgs)

	mmAddToCart.mutex.RUnlock()

	return argCopy
}

// MinimockAddToCartDone returns true if the count of the AddToCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddToCartDone() bool {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddToCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddToCartInspect() {
	for _, e := range m.AddToCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddToCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddToCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		if m.AddToCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.AddToCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddToCart with params: %#v", *m.AddToCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddToCart != nil && mm_atomic.LoadUint64(&m.afterAddToCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.AddToCart")
	}
}

type mCartRepositoryMockDeleteCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteCartExpectation
	expectations       []*CartRepositoryMockDeleteCartExpectation

	callArgs []*CartRepositoryMockDeleteCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockDeleteCartExpectation specifies expectation struct of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockDeleteCartParams
	results *CartRepositoryMockDeleteCartResults
	Counter uint64
}

// CartRepositoryMockDeleteCartParams contains parameters of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartParams struct {
	ctx    context.Context
	userID int64
	sku    uint32
}

// CartRepositoryMockDeleteCartResults contains results of the CartRepository.DeleteCart
type CartRepositoryMockDeleteCartResults struct {
	err error
}

// Expect sets up expected params for CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Expect(ctx context.Context, userID int64, sku uint32) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{}
	}

	mmDeleteCart.defaultExpectation.params = &CartRepositoryMockDeleteCartParams{ctx, userID, sku}
	for _, e := range mmDeleteCart.expectations {
		if minimock.Equal(e.params, mmDeleteCart.defaultExpectation.params) {
			mmDeleteCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteCart.defaultExpectation.params)
		}
	}

	return mmDeleteCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Inspect(f func(ctx context.Context, userID int64, sku uint32)) *mCartRepositoryMockDeleteCart {
	if mmDeleteCart.mock.inspectFuncDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteCart")
	}

	mmDeleteCart.mock.inspectFuncDeleteCart = f

	return mmDeleteCart
}

// Return sets up results that will be returned by CartRepository.DeleteCart
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Return(err error) *CartRepositoryMock {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	if mmDeleteCart.defaultExpectation == nil {
		mmDeleteCart.defaultExpectation = &CartRepositoryMockDeleteCartExpectation{mock: mmDeleteCart.mock}
	}
	mmDeleteCart.defaultExpectation.results = &CartRepositoryMockDeleteCartResults{err}
	return mmDeleteCart.mock
}

// Set uses given function f to mock the CartRepository.DeleteCart method
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Set(f func(ctx context.Context, userID int64, sku uint32) (err error)) *CartRepositoryMock {
	if mmDeleteCart.defaultExpectation != nil {
		mmDeleteCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteCart method")
	}

	if len(mmDeleteCart.expectations) > 0 {
		mmDeleteCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteCart method")
	}

	mmDeleteCart.mock.funcDeleteCart = f
	return mmDeleteCart.mock
}

// When sets expectation for the CartRepository.DeleteCart which will trigger the result defined by the following
// Then helper
func (mmDeleteCart *mCartRepositoryMockDeleteCart) When(ctx context.Context, userID int64, sku uint32) *CartRepositoryMockDeleteCartExpectation {
	if mmDeleteCart.mock.funcDeleteCart != nil {
		mmDeleteCart.mock.t.Fatalf("CartRepositoryMock.DeleteCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteCartExpectation{
		mock:   mmDeleteCart.mock,
		params: &CartRepositoryMockDeleteCartParams{ctx, userID, sku},
	}
	mmDeleteCart.expectations = append(mmDeleteCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteCartResults{err}
	return e.mock
}

// DeleteCart implements db_repository.CartRepository
func (mmDeleteCart *CartRepositoryMock) DeleteCart(ctx context.Context, userID int64, sku uint32) (err error) {
	mm_atomic.AddUint64(&mmDeleteCart.beforeDeleteCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteCart.afterDeleteCartCounter, 1)

	if mmDeleteCart.inspectFuncDeleteCart != nil {
		mmDeleteCart.inspectFuncDeleteCart(ctx, userID, sku)
	}

	mm_params := &CartRepositoryMockDeleteCartParams{ctx, userID, sku}

	// Record call args
	mmDeleteCart.DeleteCartMock.mutex.Lock()
	mmDeleteCart.DeleteCartMock.callArgs = append(mmDeleteCart.DeleteCartMock.callArgs, mm_params)
	mmDeleteCart.DeleteCartMock.mutex.Unlock()

	for _, e := range mmDeleteCart.DeleteCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteCart.DeleteCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteCart.DeleteCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteCart.DeleteCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockDeleteCartParams{ctx, userID, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteCart.t.Errorf("CartRepositoryMock.DeleteCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteCart.DeleteCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteCart")
		}
		return (*mm_results).err
	}
	if mmDeleteCart.funcDeleteCart != nil {
		return mmDeleteCart.funcDeleteCart(ctx, userID, sku)
	}
	mmDeleteCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteCart. %v %v %v", ctx, userID, sku)
	return
}

// DeleteCartAfterCounter returns a count of finished CartRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartRepositoryMock) DeleteCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.afterDeleteCartCounter)
}

// DeleteCartBeforeCounter returns a count of CartRepositoryMock.DeleteCart invocations
func (mmDeleteCart *CartRepositoryMock) DeleteCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteCart.beforeDeleteCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteCart *mCartRepositoryMockDeleteCart) Calls() []*CartRepositoryMockDeleteCartParams {
	mmDeleteCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteCartParams, len(mmDeleteCart.callArgs))
	copy(argCopy, mmDeleteCart.callArgs)

	mmDeleteCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteCartDone returns true if the count of the DeleteCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteCartDone() bool {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteCartInspect() {
	for _, e := range m.DeleteCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		if m.DeleteCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.DeleteCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteCart with params: %#v", *m.DeleteCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteCart != nil && mm_atomic.LoadUint64(&m.afterDeleteCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.DeleteCart")
	}
}

type mCartRepositoryMockDeleteUserCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteUserCartExpectation
	expectations       []*CartRepositoryMockDeleteUserCartExpectation

	callArgs []*CartRepositoryMockDeleteUserCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockDeleteUserCartExpectation specifies expectation struct of the CartRepository.DeleteUserCart
type CartRepositoryMockDeleteUserCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockDeleteUserCartParams
	results *CartRepositoryMockDeleteUserCartResults
	Counter uint64
}

// CartRepositoryMockDeleteUserCartParams contains parameters of the CartRepository.DeleteUserCart
type CartRepositoryMockDeleteUserCartParams struct {
	ctx    context.Context
	userID int64
}

// CartRepositoryMockDeleteUserCartResults contains results of the CartRepository.DeleteUserCart
type CartRepositoryMockDeleteUserCartResults struct {
	err error
}

// Expect sets up expected params for CartRepository.DeleteUserCart
func (mmDeleteUserCart *mCartRepositoryMockDeleteUserCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockDeleteUserCart {
	if mmDeleteUserCart.mock.funcDeleteUserCart != nil {
		mmDeleteUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteUserCart mock is already set by Set")
	}

	if mmDeleteUserCart.defaultExpectation == nil {
		mmDeleteUserCart.defaultExpectation = &CartRepositoryMockDeleteUserCartExpectation{}
	}

	mmDeleteUserCart.defaultExpectation.params = &CartRepositoryMockDeleteUserCartParams{ctx, userID}
	for _, e := range mmDeleteUserCart.expectations {
		if minimock.Equal(e.params, mmDeleteUserCart.defaultExpectation.params) {
			mmDeleteUserCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUserCart.defaultExpectation.params)
		}
	}

	return mmDeleteUserCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteUserCart
func (mmDeleteUserCart *mCartRepositoryMockDeleteUserCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockDeleteUserCart {
	if mmDeleteUserCart.mock.inspectFuncDeleteUserCart != nil {
		mmDeleteUserCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteUserCart")
	}

	mmDeleteUserCart.mock.inspectFuncDeleteUserCart = f

	return mmDeleteUserCart
}

// Return sets up results that will be returned by CartRepository.DeleteUserCart
func (mmDeleteUserCart *mCartRepositoryMockDeleteUserCart) Return(err error) *CartRepositoryMock {
	if mmDeleteUserCart.mock.funcDeleteUserCart != nil {
		mmDeleteUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteUserCart mock is already set by Set")
	}

	if mmDeleteUserCart.defaultExpectation == nil {
		mmDeleteUserCart.defaultExpectation = &CartRepositoryMockDeleteUserCartExpectation{mock: mmDeleteUserCart.mock}
	}
	mmDeleteUserCart.defaultExpectation.results = &CartRepositoryMockDeleteUserCartResults{err}
	return mmDeleteUserCart.mock
}

// Set uses given function f to mock the CartRepository.DeleteUserCart method
func (mmDeleteUserCart *mCartRepositoryMockDeleteUserCart) Set(f func(ctx context.Context, userID int64) (err error)) *CartRepositoryMock {
	if mmDeleteUserCart.defaultExpectation != nil {
		mmDeleteUserCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteUserCart method")
	}

	if len(mmDeleteUserCart.expectations) > 0 {
		mmDeleteUserCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteUserCart method")
	}

	mmDeleteUserCart.mock.funcDeleteUserCart = f
	return mmDeleteUserCart.mock
}

// When sets expectation for the CartRepository.DeleteUserCart which will trigger the result defined by the following
// Then helper
func (mmDeleteUserCart *mCartRepositoryMockDeleteUserCart) When(ctx context.Context, userID int64) *CartRepositoryMockDeleteUserCartExpectation {
	if mmDeleteUserCart.mock.funcDeleteUserCart != nil {
		mmDeleteUserCart.mock.t.Fatalf("CartRepositoryMock.DeleteUserCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteUserCartExpectation{
		mock:   mmDeleteUserCart.mock,
		params: &CartRepositoryMockDeleteUserCartParams{ctx, userID},
	}
	mmDeleteUserCart.expectations = append(mmDeleteUserCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteUserCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteUserCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteUserCartResults{err}
	return e.mock
}

// DeleteUserCart implements db_repository.CartRepository
func (mmDeleteUserCart *CartRepositoryMock) DeleteUserCart(ctx context.Context, userID int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUserCart.beforeDeleteUserCartCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUserCart.afterDeleteUserCartCounter, 1)

	if mmDeleteUserCart.inspectFuncDeleteUserCart != nil {
		mmDeleteUserCart.inspectFuncDeleteUserCart(ctx, userID)
	}

	mm_params := &CartRepositoryMockDeleteUserCartParams{ctx, userID}

	// Record call args
	mmDeleteUserCart.DeleteUserCartMock.mutex.Lock()
	mmDeleteUserCart.DeleteUserCartMock.callArgs = append(mmDeleteUserCart.DeleteUserCartMock.callArgs, mm_params)
	mmDeleteUserCart.DeleteUserCartMock.mutex.Unlock()

	for _, e := range mmDeleteUserCart.DeleteUserCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUserCart.DeleteUserCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUserCart.DeleteUserCartMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUserCart.DeleteUserCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockDeleteUserCartParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUserCart.t.Errorf("CartRepositoryMock.DeleteUserCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUserCart.DeleteUserCartMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUserCart.t.Fatal("No results are set for the CartRepositoryMock.DeleteUserCart")
		}
		return (*mm_results).err
	}
	if mmDeleteUserCart.funcDeleteUserCart != nil {
		return mmDeleteUserCart.funcDeleteUserCart(ctx, userID)
	}
	mmDeleteUserCart.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteUserCart. %v %v", ctx, userID)
	return
}

// DeleteUserCartAfterCounter returns a count of finished CartRepositoryMock.DeleteUserCart invocations
func (mmDeleteUserCart *CartRepositoryMock) DeleteUserCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserCart.afterDeleteUserCartCounter)
}

// DeleteUserCartBeforeCounter returns a count of CartRepositoryMock.DeleteUserCart invocations
func (mmDeleteUserCart *CartRepositoryMock) DeleteUserCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUserCart.beforeDeleteUserCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteUserCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUserCart *mCartRepositoryMockDeleteUserCart) Calls() []*CartRepositoryMockDeleteUserCartParams {
	mmDeleteUserCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteUserCartParams, len(mmDeleteUserCart.callArgs))
	copy(argCopy, mmDeleteUserCart.callArgs)

	mmDeleteUserCart.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserCartDone returns true if the count of the DeleteUserCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteUserCartDone() bool {
	for _, e := range m.DeleteUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUserCart != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteUserCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteUserCartInspect() {
	for _, e := range m.DeleteUserCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteUserCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCartCounter) < 1 {
		if m.DeleteUserCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.DeleteUserCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteUserCart with params: %#v", *m.DeleteUserCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUserCart != nil && mm_atomic.LoadUint64(&m.afterDeleteUserCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.DeleteUserCart")
	}
}

type mCartRepositoryMockGetCartItem struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartItemExpectation
	expectations       []*CartRepositoryMockGetCartItemExpectation

	callArgs []*CartRepositoryMockGetCartItemParams
	mutex    sync.RWMutex
}

// CartRepositoryMockGetCartItemExpectation specifies expectation struct of the CartRepository.GetCartItem
type CartRepositoryMockGetCartItemExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockGetCartItemParams
	results *CartRepositoryMockGetCartItemResults
	Counter uint64
}

// CartRepositoryMockGetCartItemParams contains parameters of the CartRepository.GetCartItem
type CartRepositoryMockGetCartItemParams struct {
	ctx    context.Context
	userID int64
	sku    uint32
}

// CartRepositoryMockGetCartItemResults contains results of the CartRepository.GetCartItem
type CartRepositoryMockGetCartItemResults struct {
	c2  model.CartItem
	err error
}

// Expect sets up expected params for CartRepository.GetCartItem
func (mmGetCartItem *mCartRepositoryMockGetCartItem) Expect(ctx context.Context, userID int64, sku uint32) *mCartRepositoryMockGetCartItem {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("CartRepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &CartRepositoryMockGetCartItemExpectation{}
	}

	mmGetCartItem.defaultExpectation.params = &CartRepositoryMockGetCartItemParams{ctx, userID, sku}
	for _, e := range mmGetCartItem.expectations {
		if minimock.Equal(e.params, mmGetCartItem.defaultExpectation.params) {
			mmGetCartItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartItem.defaultExpectation.params)
		}
	}

	return mmGetCartItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCartItem
func (mmGetCartItem *mCartRepositoryMockGetCartItem) Inspect(f func(ctx context.Context, userID int64, sku uint32)) *mCartRepositoryMockGetCartItem {
	if mmGetCartItem.mock.inspectFuncGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCartItem")
	}

	mmGetCartItem.mock.inspectFuncGetCartItem = f

	return mmGetCartItem
}

// Return sets up results that will be returned by CartRepository.GetCartItem
func (mmGetCartItem *mCartRepositoryMockGetCartItem) Return(c2 model.CartItem, err error) *CartRepositoryMock {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("CartRepositoryMock.GetCartItem mock is already set by Set")
	}

	if mmGetCartItem.defaultExpectation == nil {
		mmGetCartItem.defaultExpectation = &CartRepositoryMockGetCartItemExpectation{mock: mmGetCartItem.mock}
	}
	mmGetCartItem.defaultExpectation.results = &CartRepositoryMockGetCartItemResults{c2, err}
	return mmGetCartItem.mock
}

// Set uses given function f to mock the CartRepository.GetCartItem method
func (mmGetCartItem *mCartRepositoryMockGetCartItem) Set(f func(ctx context.Context, userID int64, sku uint32) (c2 model.CartItem, err error)) *CartRepositoryMock {
	if mmGetCartItem.defaultExpectation != nil {
		mmGetCartItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCartItem method")
	}

	if len(mmGetCartItem.expectations) > 0 {
		mmGetCartItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCartItem method")
	}

	mmGetCartItem.mock.funcGetCartItem = f
	return mmGetCartItem.mock
}

// When sets expectation for the CartRepository.GetCartItem which will trigger the result defined by the following
// Then helper
func (mmGetCartItem *mCartRepositoryMockGetCartItem) When(ctx context.Context, userID int64, sku uint32) *CartRepositoryMockGetCartItemExpectation {
	if mmGetCartItem.mock.funcGetCartItem != nil {
		mmGetCartItem.mock.t.Fatalf("CartRepositoryMock.GetCartItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartItemExpectation{
		mock:   mmGetCartItem.mock,
		params: &CartRepositoryMockGetCartItemParams{ctx, userID, sku},
	}
	mmGetCartItem.expectations = append(mmGetCartItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCartItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartItemExpectation) Then(c2 model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartItemResults{c2, err}
	return e.mock
}

// GetCartItem implements db_repository.CartRepository
func (mmGetCartItem *CartRepositoryMock) GetCartItem(ctx context.Context, userID int64, sku uint32) (c2 model.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCartItem.beforeGetCartItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartItem.afterGetCartItemCounter, 1)

	if mmGetCartItem.inspectFuncGetCartItem != nil {
		mmGetCartItem.inspectFuncGetCartItem(ctx, userID, sku)
	}

	mm_params := &CartRepositoryMockGetCartItemParams{ctx, userID, sku}

	// Record call args
	mmGetCartItem.GetCartItemMock.mutex.Lock()
	mmGetCartItem.GetCartItemMock.callArgs = append(mmGetCartItem.GetCartItemMock.callArgs, mm_params)
	mmGetCartItem.GetCartItemMock.mutex.Unlock()

	for _, e := range mmGetCartItem.GetCartItemMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmGetCartItem.GetCartItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartItem.GetCartItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartItem.GetCartItemMock.defaultExpectation.params
		mm_got := CartRepositoryMockGetCartItemParams{ctx, userID, sku}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartItem.t.Errorf("CartRepositoryMock.GetCartItem got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartItem.GetCartItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartItem.t.Fatal("No results are set for the CartRepositoryMock.GetCartItem")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmGetCartItem.funcGetCartItem != nil {
		return mmGetCartItem.funcGetCartItem(ctx, userID, sku)
	}
	mmGetCartItem.t.Fatalf("Unexpected call to CartRepositoryMock.GetCartItem. %v %v %v", ctx, userID, sku)
	return
}

// GetCartItemAfterCounter returns a count of finished CartRepositoryMock.GetCartItem invocations
func (mmGetCartItem *CartRepositoryMock) GetCartItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.afterGetCartItemCounter)
}

// GetCartItemBeforeCounter returns a count of CartRepositoryMock.GetCartItem invocations
func (mmGetCartItem *CartRepositoryMock) GetCartItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartItem.beforeGetCartItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCartItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartItem *mCartRepositoryMockGetCartItem) Calls() []*CartRepositoryMockGetCartItemParams {
	mmGetCartItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartItemParams, len(mmGetCartItem.callArgs))
	copy(argCopy, mmGetCartItem.callArgs)

	mmGetCartItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartItemDone returns true if the count of the GetCartItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartItemDone() bool {
	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItem != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetCartItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartItemInspect() {
	for _, e := range m.GetCartItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCartItem with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartItemMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		if m.GetCartItemMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.GetCartItem")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCartItem with params: %#v", *m.GetCartItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartItem != nil && mm_atomic.LoadUint64(&m.afterGetCartItemCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.GetCartItem")
	}
}

type mCartRepositoryMockListCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockListCartExpectation
	expectations       []*CartRepositoryMockListCartExpectation

	callArgs []*CartRepositoryMockListCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockListCartExpectation specifies expectation struct of the CartRepository.ListCart
type CartRepositoryMockListCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockListCartParams
	results *CartRepositoryMockListCartResults
	Counter uint64
}

// CartRepositoryMockListCartParams contains parameters of the CartRepository.ListCart
type CartRepositoryMockListCartParams struct {
	ctx    context.Context
	userID int64
}

// CartRepositoryMockListCartResults contains results of the CartRepository.ListCart
type CartRepositoryMockListCartResults struct {
	ca1 []model.CartItem
	err error
}

// Expect sets up expected params for CartRepository.ListCart
func (mmListCart *mCartRepositoryMockListCart) Expect(ctx context.Context, userID int64) *mCartRepositoryMockListCart {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartRepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CartRepositoryMockListCartExpectation{}
	}

	mmListCart.defaultExpectation.params = &CartRepositoryMockListCartParams{ctx, userID}
	for _, e := range mmListCart.expectations {
		if minimock.Equal(e.params, mmListCart.defaultExpectation.params) {
			mmListCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListCart.defaultExpectation.params)
		}
	}

	return mmListCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.ListCart
func (mmListCart *mCartRepositoryMockListCart) Inspect(f func(ctx context.Context, userID int64)) *mCartRepositoryMockListCart {
	if mmListCart.mock.inspectFuncListCart != nil {
		mmListCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.ListCart")
	}

	mmListCart.mock.inspectFuncListCart = f

	return mmListCart
}

// Return sets up results that will be returned by CartRepository.ListCart
func (mmListCart *mCartRepositoryMockListCart) Return(ca1 []model.CartItem, err error) *CartRepositoryMock {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartRepositoryMock.ListCart mock is already set by Set")
	}

	if mmListCart.defaultExpectation == nil {
		mmListCart.defaultExpectation = &CartRepositoryMockListCartExpectation{mock: mmListCart.mock}
	}
	mmListCart.defaultExpectation.results = &CartRepositoryMockListCartResults{ca1, err}
	return mmListCart.mock
}

// Set uses given function f to mock the CartRepository.ListCart method
func (mmListCart *mCartRepositoryMockListCart) Set(f func(ctx context.Context, userID int64) (ca1 []model.CartItem, err error)) *CartRepositoryMock {
	if mmListCart.defaultExpectation != nil {
		mmListCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.ListCart method")
	}

	if len(mmListCart.expectations) > 0 {
		mmListCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.ListCart method")
	}

	mmListCart.mock.funcListCart = f
	return mmListCart.mock
}

// When sets expectation for the CartRepository.ListCart which will trigger the result defined by the following
// Then helper
func (mmListCart *mCartRepositoryMockListCart) When(ctx context.Context, userID int64) *CartRepositoryMockListCartExpectation {
	if mmListCart.mock.funcListCart != nil {
		mmListCart.mock.t.Fatalf("CartRepositoryMock.ListCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockListCartExpectation{
		mock:   mmListCart.mock,
		params: &CartRepositoryMockListCartParams{ctx, userID},
	}
	mmListCart.expectations = append(mmListCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.ListCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockListCartExpectation) Then(ca1 []model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockListCartResults{ca1, err}
	return e.mock
}

// ListCart implements db_repository.CartRepository
func (mmListCart *CartRepositoryMock) ListCart(ctx context.Context, userID int64) (ca1 []model.CartItem, err error) {
	mm_atomic.AddUint64(&mmListCart.beforeListCartCounter, 1)
	defer mm_atomic.AddUint64(&mmListCart.afterListCartCounter, 1)

	if mmListCart.inspectFuncListCart != nil {
		mmListCart.inspectFuncListCart(ctx, userID)
	}

	mm_params := &CartRepositoryMockListCartParams{ctx, userID}

	// Record call args
	mmListCart.ListCartMock.mutex.Lock()
	mmListCart.ListCartMock.callArgs = append(mmListCart.ListCartMock.callArgs, mm_params)
	mmListCart.ListCartMock.mutex.Unlock()

	for _, e := range mmListCart.ListCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmListCart.ListCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListCart.ListCartMock.defaultExpectation.Counter, 1)
		mm_want := mmListCart.ListCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockListCartParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListCart.t.Errorf("CartRepositoryMock.ListCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListCart.ListCartMock.defaultExpectation.results
		if mm_results == nil {
			mmListCart.t.Fatal("No results are set for the CartRepositoryMock.ListCart")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmListCart.funcListCart != nil {
		return mmListCart.funcListCart(ctx, userID)
	}
	mmListCart.t.Fatalf("Unexpected call to CartRepositoryMock.ListCart. %v %v", ctx, userID)
	return
}

// ListCartAfterCounter returns a count of finished CartRepositoryMock.ListCart invocations
func (mmListCart *CartRepositoryMock) ListCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.afterListCartCounter)
}

// ListCartBeforeCounter returns a count of CartRepositoryMock.ListCart invocations
func (mmListCart *CartRepositoryMock) ListCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListCart.beforeListCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.ListCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListCart *mCartRepositoryMockListCart) Calls() []*CartRepositoryMockListCartParams {
	mmListCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockListCartParams, len(mmListCart.callArgs))
	copy(argCopy, mmListCart.callArgs)

	mmListCart.mutex.RUnlock()

	return argCopy
}

// MinimockListCartDone returns true if the count of the ListCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockListCartDone() bool {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockListCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockListCartInspect() {
	for _, e := range m.ListCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.ListCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		if m.ListCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.ListCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.ListCart with params: %#v", *m.ListCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListCart != nil && mm_atomic.LoadUint64(&m.afterListCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.ListCart")
	}
}

type mCartRepositoryMockUpdateCountCart struct {
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockUpdateCountCartExpectation
	expectations       []*CartRepositoryMockUpdateCountCartExpectation

	callArgs []*CartRepositoryMockUpdateCountCartParams
	mutex    sync.RWMutex
}

// CartRepositoryMockUpdateCountCartExpectation specifies expectation struct of the CartRepository.UpdateCountCart
type CartRepositoryMockUpdateCountCartExpectation struct {
	mock    *CartRepositoryMock
	params  *CartRepositoryMockUpdateCountCartParams
	results *CartRepositoryMockUpdateCountCartResults
	Counter uint64
}

// CartRepositoryMockUpdateCountCartParams contains parameters of the CartRepository.UpdateCountCart
type CartRepositoryMockUpdateCountCartParams struct {
	ctx    context.Context
	userID int64
	sku    uint32
	count  uint32
}

// CartRepositoryMockUpdateCountCartResults contains results of the CartRepository.UpdateCountCart
type CartRepositoryMockUpdateCountCartResults struct {
	err error
}

// Expect sets up expected params for CartRepository.UpdateCountCart
func (mmUpdateCountCart *mCartRepositoryMockUpdateCountCart) Expect(ctx context.Context, userID int64, sku uint32, count uint32) *mCartRepositoryMockUpdateCountCart {
	if mmUpdateCountCart.mock.funcUpdateCountCart != nil {
		mmUpdateCountCart.mock.t.Fatalf("CartRepositoryMock.UpdateCountCart mock is already set by Set")
	}

	if mmUpdateCountCart.defaultExpectation == nil {
		mmUpdateCountCart.defaultExpectation = &CartRepositoryMockUpdateCountCartExpectation{}
	}

	mmUpdateCountCart.defaultExpectation.params = &CartRepositoryMockUpdateCountCartParams{ctx, userID, sku, count}
	for _, e := range mmUpdateCountCart.expectations {
		if minimock.Equal(e.params, mmUpdateCountCart.defaultExpectation.params) {
			mmUpdateCountCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCountCart.defaultExpectation.params)
		}
	}

	return mmUpdateCountCart
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.UpdateCountCart
func (mmUpdateCountCart *mCartRepositoryMockUpdateCountCart) Inspect(f func(ctx context.Context, userID int64, sku uint32, count uint32)) *mCartRepositoryMockUpdateCountCart {
	if mmUpdateCountCart.mock.inspectFuncUpdateCountCart != nil {
		mmUpdateCountCart.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.UpdateCountCart")
	}

	mmUpdateCountCart.mock.inspectFuncUpdateCountCart = f

	return mmUpdateCountCart
}

// Return sets up results that will be returned by CartRepository.UpdateCountCart
func (mmUpdateCountCart *mCartRepositoryMockUpdateCountCart) Return(err error) *CartRepositoryMock {
	if mmUpdateCountCart.mock.funcUpdateCountCart != nil {
		mmUpdateCountCart.mock.t.Fatalf("CartRepositoryMock.UpdateCountCart mock is already set by Set")
	}

	if mmUpdateCountCart.defaultExpectation == nil {
		mmUpdateCountCart.defaultExpectation = &CartRepositoryMockUpdateCountCartExpectation{mock: mmUpdateCountCart.mock}
	}
	mmUpdateCountCart.defaultExpectation.results = &CartRepositoryMockUpdateCountCartResults{err}
	return mmUpdateCountCart.mock
}

// Set uses given function f to mock the CartRepository.UpdateCountCart method
func (mmUpdateCountCart *mCartRepositoryMockUpdateCountCart) Set(f func(ctx context.Context, userID int64, sku uint32, count uint32) (err error)) *CartRepositoryMock {
	if mmUpdateCountCart.defaultExpectation != nil {
		mmUpdateCountCart.mock.t.Fatalf("Default expectation is already set for the CartRepository.UpdateCountCart method")
	}

	if len(mmUpdateCountCart.expectations) > 0 {
		mmUpdateCountCart.mock.t.Fatalf("Some expectations are already set for the CartRepository.UpdateCountCart method")
	}

	mmUpdateCountCart.mock.funcUpdateCountCart = f
	return mmUpdateCountCart.mock
}

// When sets expectation for the CartRepository.UpdateCountCart which will trigger the result defined by the following
// Then helper
func (mmUpdateCountCart *mCartRepositoryMockUpdateCountCart) When(ctx context.Context, userID int64, sku uint32, count uint32) *CartRepositoryMockUpdateCountCartExpectation {
	if mmUpdateCountCart.mock.funcUpdateCountCart != nil {
		mmUpdateCountCart.mock.t.Fatalf("CartRepositoryMock.UpdateCountCart mock is already set by Set")
	}

	expectation := &CartRepositoryMockUpdateCountCartExpectation{
		mock:   mmUpdateCountCart.mock,
		params: &CartRepositoryMockUpdateCountCartParams{ctx, userID, sku, count},
	}
	mmUpdateCountCart.expectations = append(mmUpdateCountCart.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.UpdateCountCart return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockUpdateCountCartExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockUpdateCountCartResults{err}
	return e.mock
}

// UpdateCountCart implements db_repository.CartRepository
func (mmUpdateCountCart *CartRepositoryMock) UpdateCountCart(ctx context.Context, userID int64, sku uint32, count uint32) (err error) {
	mm_atomic.AddUint64(&mmUpdateCountCart.beforeUpdateCountCartCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCountCart.afterUpdateCountCartCounter, 1)

	if mmUpdateCountCart.inspectFuncUpdateCountCart != nil {
		mmUpdateCountCart.inspectFuncUpdateCountCart(ctx, userID, sku, count)
	}

	mm_params := &CartRepositoryMockUpdateCountCartParams{ctx, userID, sku, count}

	// Record call args
	mmUpdateCountCart.UpdateCountCartMock.mutex.Lock()
	mmUpdateCountCart.UpdateCountCartMock.callArgs = append(mmUpdateCountCart.UpdateCountCartMock.callArgs, mm_params)
	mmUpdateCountCart.UpdateCountCartMock.mutex.Unlock()

	for _, e := range mmUpdateCountCart.UpdateCountCartMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateCountCart.UpdateCountCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCountCart.UpdateCountCartMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCountCart.UpdateCountCartMock.defaultExpectation.params
		mm_got := CartRepositoryMockUpdateCountCartParams{ctx, userID, sku, count}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCountCart.t.Errorf("CartRepositoryMock.UpdateCountCart got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCountCart.UpdateCountCartMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCountCart.t.Fatal("No results are set for the CartRepositoryMock.UpdateCountCart")
		}
		return (*mm_results).err
	}
	if mmUpdateCountCart.funcUpdateCountCart != nil {
		return mmUpdateCountCart.funcUpdateCountCart(ctx, userID, sku, count)
	}
	mmUpdateCountCart.t.Fatalf("Unexpected call to CartRepositoryMock.UpdateCountCart. %v %v %v %v", ctx, userID, sku, count)
	return
}

// UpdateCountCartAfterCounter returns a count of finished CartRepositoryMock.UpdateCountCart invocations
func (mmUpdateCountCart *CartRepositoryMock) UpdateCountCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCountCart.afterUpdateCountCartCounter)
}

// UpdateCountCartBeforeCounter returns a count of CartRepositoryMock.UpdateCountCart invocations
func (mmUpdateCountCart *CartRepositoryMock) UpdateCountCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCountCart.beforeUpdateCountCartCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.UpdateCountCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCountCart *mCartRepositoryMockUpdateCountCart) Calls() []*CartRepositoryMockUpdateCountCartParams {
	mmUpdateCountCart.mutex.RLock()

	argCopy := make([]*CartRepositoryMockUpdateCountCartParams, len(mmUpdateCountCart.callArgs))
	copy(argCopy, mmUpdateCountCart.callArgs)

	mmUpdateCountCart.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCountCartDone returns true if the count of the UpdateCountCart invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockUpdateCountCartDone() bool {
	for _, e := range m.UpdateCountCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCountCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCountCartCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCountCart != nil && mm_atomic.LoadUint64(&m.afterUpdateCountCartCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateCountCartInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockUpdateCountCartInspect() {
	for _, e := range m.UpdateCountCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.UpdateCountCart with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCountCartMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCountCartCounter) < 1 {
		if m.UpdateCountCartMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CartRepositoryMock.UpdateCountCart")
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.UpdateCountCart with params: %#v", *m.UpdateCountCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCountCart != nil && mm_atomic.LoadUint64(&m.afterUpdateCountCartCounter) < 1 {
		m.t.Error("Expected call to CartRepositoryMock.UpdateCountCart")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddToCartInspect()

		m.MinimockDeleteCartInspect()

		m.MinimockDeleteUserCartInspect()

		m.MinimockGetCartItemInspect()

		m.MinimockListCartInspect()

		m.MinimockUpdateCountCartInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddToCartDone() &&
		m.MinimockDeleteCartDone() &&
		m.MinimockDeleteUserCartDone() &&
		m.MinimockGetCartItemDone() &&
		m.MinimockListCartDone() &&
		m.MinimockUpdateCountCartDone()
}
